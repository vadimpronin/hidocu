# HiDocu

**A native macOS management suite for HiDock audio recording devices focused on transcription accuracy, data
sovereignty, and professional workflows.**

## Overview

HiDocu is a native macOS application designed to replace the proprietary HiNotes software for managing audio recordings
from HiDock hardware (H1, H1E, P1, and P1 Mini).

HiDocu's promises are simple:

- **No compromises on transcription quality**, no matter the language or technical jargon.
- **No paywalls or subscriptions**: all features are available for free.
- **Full privacy for sensitive recordings**: use only local models for maximum privacy, or connect to your own API keys
  for best-in-class transcription and analysis.
- **Full control over your data**: all audio files and metadata are stored locally. You decide if and when to sync or
  backup your recordings to the cloud of your choice.

## Motivation

This project addresses specific limitations found in the official HiNotes software:

* **Context-aware transcription:** Most transcription services treat audio as isolated segments, ignoring the broader
  context, specific terminology, or slang used in meetings. HiDocu is designed to leverage meeting metadata (e.g.,
  calendar events, participant lists) and company-specific glossaries to provide richer context, resulting in more
  accurate and relevant transcripts.
* **Mixed-language transcription:** HiDocu is optimized for meetings involving multiple languages or dialects, where
  speakers can jump between two, three, or more languages in the same sentence.
* **Focus on transcription accuracy over speed:** HiDocu prioritizes transcription accuracy. For complex scenarios, a
  user may choose to automatically create multiple variants of the same transcription (e.g., using different models or
  settings) and use an LLM-judge to select the most accurate one.
* **Proper and free speaker identification:** If the model provides speaker diarization, HiDocu captures and stores this
  information in the transcription metadata at no extra cost. It also makes an extra effort to map each phrase to the
  correct speaker based on the context of what is said and who was present in the meeting.
* **Focus on privacy and data control:** HiDocu treats sensitive audio recordings with the utmost care. The app is
  designed to operate primarily as a local application, ensuring that sensitive audio recordings remain only on the
  user's machine. The user chooses if they want to backup the data to a cloud service of their choice (e.g., iCloud,
  Dropbox) or if they want to use cloud or local-only transcription models. For cloud transcription, users bring their
  own API keys (BYOK), ensuring that no third-party service has access to their data without explicit permission.
* **Free automatic sync and transcription:** HiDocu does not hide critical features like automatic download and
  transcription behind paywalls.
* **Multi-project management:** Keep your professional and personal recordings separate. HiDocu allows users to organize
  recordings into multiple layers of folders or projects, each with its own transcription settings, glossaries, and
  cloud backup preferences. Multiple calendar accounts can be linked to different projects for automatic meeting
  association.
* **No subscriptions and cost transparency:** HiDocu is open-source and free to use without any subscriptions. Users can
  opt-out of cloud transcription and summarization entirely and use local models only. If cloud models are used, users
  bring their own API keys and are billed directly by the service provider (e.g., OpenAI, Google), ensuring full cost
  transparency.
* **Easy to use:** HiDocu features a modern, intuitive 3-column user interface, similar to native Apple apps like Mail,
  Contacts, or Notes, where all your folders and recordings are easily accessible and searchable without complex
  navigation.
* **Talk to your meetings:** Had a series of recurring meetings? Five rounds of interviews? Two years of team
  stand-ups? No problem. HiDocu allows you to query a group of meetings using your favorite LLM (local or cloud) to
  extract insights, ask questions, or find patterns across multiple transcripts or summaries.

## Hardware Support

* **HiDock H1** (Desktop Audio Dock)
* **HiDock H1E** (Essential Dock)
* **HiDock P1** (Portable AI Recorder)
* **HiDock P1 Mini** (Ultra-portable Recorder)

*Note: This project is not affiliated with, endorsed by, or sponsored by HiDock.*

---

## Project Structure

This monorepo is divided into three distinct components:

1. **`HiDocu`**: The main native macOS application.
2. **`hidock-cli`**: A command-line tool for power users and scripters to interact with HiDock devices without a GUI.
3. **`JensenUSB`**: A pure Swift library handling low-level IOKit communication, protocol encoding/decoding, and device
   state management. It serves as the driver layer.

## Installation & Building

### Prerequisites

* macOS 12.0 (Monterey) or later
* Xcode 15+ (Swift 5.9+)

### Build from Source

A `Makefile` is provided to orchestrate the build process for both the CLI and the GUI app.

```bash
# Clone the repository
git clone [https://github.com/vadimpronin/hidocu.git](https://github.com/vadimpronin/hidocu.git)
cd hidocu

# Build the GUI Application
make hidocu
# App will be located at: build/gui/Build/Products/Release/HiDocu.app

# Build the CLI tool
make build

# Run Unit Tests (Safe to run without device)
make test

# HiDocu Concept Change

HiDocu is a native macOS application designed to replace the proprietary HiNotes software for managing audio recordings
from HiDock hardware (H1, H1E, P1, and P1 Mini).

Я хочу поменять концепт своей HiDocu app.
Новый концепт: HiDocu — это Artificial Memory / Context Management System для LLM.

Пользователь может создавать контексты из своих документов (заметки, стенограммы встреч, документация, планы, идеи и
т.п.) и использовать эти контексты для общения с любой LLM: ChatGPT, Gemini, Claude и т.д. Контекст формируется на
основании документов (Documents), находящихся в одной папке или проекте, включая все вложенные папки.
HiDocu помогает хранить и структурировать эти документы, а также автоматически формировать документы на основании
аудиозаписей встреч, календарных событий и т.п.

Основные принципы HiDocu:

- **All basic features are free, No paywalls or subscriptions**: HiDocu предоставляет все базовые функции бесплатно, без
  платных подписок или
  ограничений. Использование облачных моделей для транскрипции *требует* оплаты или использования free tier этих
  моделей, но пользователь предоставляет свои API-ключи или подписку и оплачивает эти модели напрямую, без посредников и
  без скрытых комиссий со стороны HiDocu. Так же пользователь может полностью отказаться от использования облачных
  моделей и использовать только локальные модели для транскрипции и анализа, и в этом случае все функции HiDocu будут
  доступны бесплатно.
- **No compromises on transcription quality**, no matter the language or technical jargon. Пользователь *может*
  использовать SOTA модели, несколько прогонов и LLM-Judge для выбора лучшего транскрипта. В случае если пользователь
  выбирает локальные или более дешёвые модели, HiDocu делает всё возможное, чтобы улучшить качество транскрипта за счёт
  использования контекста (например, информации о встрече из календаря, списка участников, глоссария терминов компании и
  т.п.) и пост-обработки транскрипта с помощью LLM.
- **Full privacy and full control of your data**: пользователь может использовать приложение в режиме offline-only,
  используя только локальное хранилище данных (локальную БД + локальный git-репозиторий + локальную файловую систему)
  и локальные модели для транскрипции и анализа. Либо подключать свои API-ключи для использования облачных моделей для
  транскрипции и анализа, оставляя за собой выбор, какие модели использовать и как оплачивать их использование (личной
  подпиской, оплатой за использование API либо free tier). В любом случае все данные (аудиофайлы, документы,
  метаданные) не передаются HiDocu и не хранятся в облаке HiDocu, так как HiDocu — это локальное приложение, которое
  работает с данными, хранящимися на диске пользователя либо в личном облачном хранилище пользователя (например, личном
  или корпоративном iCloud, Dropbox для аудиофайлов и GitHub/GitLab для документов, метаданных и настроек). В будущем
  некоторые функции могут потребовать отправку данных на сервер HiDocu для обработки, но это будет происходить только с
  явного разрешения пользователя, и пользователь всегда будет иметь возможность не использовать эти функции либо
  использовать упрощённый локальный вариант (там, где это будет возможно).

## Context

Context — это структурированная информация, вокруг которой пользователь может общаться с любой LLM: ChatGPT, Gemini,
Claude и т.д. Context формируется на основании документов (Documents), находящихся в одной папке или проекте, включая
все
вложенные папки. Пользователь может сформировать контекст из папки (Folder) и использовать его в
запросе к LLM. Например, HiDocu может взять все документы из папки "1:1s with John" и передать их в виде контекста в
запрос к ChatGPT/Gemini/AI Studio, чтобы получить инсайты о том, что обсуждалось на этих встречах. Сам чат с контекстом
может происходить внутри HiDocu (через встроенный чат) или в любом другом месте (например, в браузере на
chat.openai.com) — пользователь просто копирует контекст из HiDocu и вставляет его в чат.

### Механизм формирования контекста

Контекс - это сконкатенированные документы (Body или Summary). По-умолчанию выбирается Summary. Если Summary нет или
пользователь в настройках документа или папки указал использовать Body, то выбирается Body.

Интерфейс приложения может показывать приблизительное количество токенов всего контекста всей папки или выбранных
документов, чтобы пользователь понимал, сколько токенов он отправляет в LLM, и при необходимости мог отредактировать
Body или Summary документов либо включить настройку "minimize before sending to LLM", чтобы уменьшить количество
токенов.

Разные модели имеют разные ограничения по количеству токенов в контексте, поэтому пользователь может указать какую
модель он собирается использовать и приложение постарается использовать токенизатор этой модели (если он есть, а если
нет - generic токенизатор), и показать пользователю стандартным, желтым или красным цветом, сколько токенов в контексте
и не превышает ли он лимит этой модели.

## Document

Document — это единица информации внутри Context, состоящая из Plain Text в формате Markdown. Document может быть чем
угодно: заметкой, стенограммой встречи, документацией и т.п. Документ может содержать прикреплённые Sources.
Документ состоит из следующих основных частей:

- **Body** — полное тело документа в виде Markdown-текста.
- **Summary** — для длинных документов, стенограмм и т.п. это краткое резюме, сформированное автоматически (с помощью
  LLM) на
  основании Body. Например, для стенограммы встречи Summary может содержать краткое описание того, что обсуждалось на
  встрече, а Body будет содержать полную стенограмму этой встречи. Иногда Summary может быть не нужен, тогда он может
  быть пустым.
- **Metadata** — метаданные документа: название, дата создания и т.п., включая настройки документа (например, нужно ли
  минимизировать Body перед отправкой в LLM и т.п.) и метаданные, присущие конкретному типу документа (например, для
  стенограммы это может быть список спикеров, ID ивента в календаре и т.п.).

Пользователь может редактировать Body и Summary.

Документ хранится в виде файла на диске и версионируется через Git. У документа есть метаданные (название, дата
создания и т.п.), которые хранятся в отдельном файле и дублируются в базе данных для
удобства поиска и отображения в UI. В случае повреждения или удаления базы данных все документы в git могут быть
реиндексированы и восстановлены в базе данных. Summary также хранится в виде .md-файла в git и в базе данных для
удобства отображения в UI.

Примеры типовых документов:

- Стенограмма встречи. Body содержит полную стенограмму встречи, а Summary содержит краткое описание того, что
  обсуждалось на встрече.
- Заметка, созданная вручную либо на основании голосовой заметки.
- Документация.
- Задачи, планы, идеи и т.п., созданные вручную.
- Словарь доменных терминов, которые используются в компании.
- Список сотрудников компании с их ролями и контактами.
- Исходный код проекта (созданный из динамического источника).
- Email-/Slack-переписка (созданная из динамического источника).
- и т.д.

Физически на диске документ представлен в виде папки с расширением `.document`, внутри которой в качестве отдельных
файлов
хранятся:

- Markdown-файл с Body документа (`body.md`)
- Markdown-файл с Summary документа (`summary.md`)
- YAML-файл с метаданными и настройками документа (`metadata.yaml`)
- Папка `sources`, внутри которой хранятся метаданные источников (Sources). Каждый источник представлен в виде папки с
  расширением `.source`, внутри которой хранится:
    - YAML-файл с метаданными и настройками этого источника (если это динамический источник, то внутри этого YAML-файла
      будет указано, как вызывать этот источник для получения его данных).
    - Дополнительные markdown-файлы, характерные для этого источника. Например:
        - Если это аудиофайл, содержащий несколько вариантов транскрипта, то внутри папки этого источника будет
          несколько
          markdown-файлов с этими вариантами транскрипта, а в метаданных будет указано, какой из этих вариантов является
          Primary.
        - Если это PDF-файл, то внутри папки этого источника будет markdown-файл с текстом этого PDF, который был
          сгенерирован с помощью OCR или других методов конвертации PDF в текст.
        - Если это картинка, то внутри папки этого источника будет markdown-файл с описанием этой картинки, который был
          сгенерирован с помощью LLM на основании этой картинки.
        - Если это календарное событие, то внутри папки этого источника будет markdown-файл с деталями этого события,
          который был сгенерирован с помощью интеграции с календарём.
        - Для динамического источника в markdown-файл сохраняется слепок полученных данных на момент последнего запроса
          к этому источнику (например snapshot.md), а в метаданных этого источника указано, как
          получать эти данные при каждом запросе к этому источнику. При этом файл со слепком последнего ответа вносится
          в .gitignore, так как он не является источником правды для этого документа, а является всего лишь кэшем,
          который может быть легко восстановлен при необходимости.

Документ может содержать настройку "minimize before sending to LLM", которая указывает, нужно ли минимизировать
Body этого документа перед тем, как отдавать его в качестве контекста в LLM. Минимизация может включать в себя удаление
лишних пробелов или отступов, минимизацию JSON-структур и т.п.

Открытая карточка документа в UI может показывать приблизительное количество токенов в Body и/или Summary этого
документа (в полном и в минимизированном виде), чтобы пользователь понимал, сколько токенов он отправляет в LLM, и при
необходимости мог отредактировать Body или Summary либо включить настройку "minimize before sending to LLM", чтобы
уменьшить количество токенов.

### Интерфейс работы с телом документа

Пользователь может редактировать Body документа напрямую, открывая его в виде Markdown-текста и редактируя этот текст,
либо через UI, который понимает тип документа и позволяет редактировать его в более удобной форме. Например:

- Для документа-стенограммы это может быть UI с разделением на спикеров и таймстампы, а также возможностью прослушать
  нужный аудиофайл с нужного момента нажатием на фрагмент стенограммы и т.п.
- Для JSON-документа это может быть UI с редактором JSON, который позволяет редактировать JSON в виде дерева, а не в
  виде текста, и при этом сохранять отступы и форматирование, чтобы было удобно читать этот JSON.
- Для динамических документов — соответствующее отображение контента: например, если это документ с данными из БД, то
  отображать эти данные в виде таблицы, которая обновляется при каждом
  запросе к этому документу. При этом в таком интерфейсе не обязательно давать пользователю возможность редактировать
  Body документа, так как он генерируется динамически на основании источника.
- Для всех остальных типов документов, которые не имеют специфичного типа контента, это может быть обычный Markdown-
  редактор и renderer.

## Source

Документ может содержать один или несколько источников (Sources), из которых он был создан. Примеры источников:

- **Аудиофайлы (Recordings)** с записью встречи (1, 2, 3, N частей). В этом случае Body будет
  содержать стенограмму встречи, а прикреплённые аудиофайлы будут источниками для этой стенограммы.
- **Calendar Events.** В этом случае Body будет содержать дату/время ивента, список участников, детали встречи (
  например,
  описание из календаря). Документ, содержащий Calendar Event в качестве Source, также будет содержать в качестве
  дополнительных Sources аудиофайл(-ы) с записью этой встречи. В этом случае Body будет содержать информацию об ивенте
  из календаря + стенограмму встречи.
- **Голосовые заметки** (разновидность Recording), которые пользователь записал в дороге. В этом случае Body будет
  содержать стенограммы всех этих заметок, собранные в один документ в виде текста.
- **PDF-файл.** В этом случае Body будет содержать этот PDF, сконвертированный в текст (например, через OCR или
  другие методы), а прикреплённый PDF-файл будет источником для этого документа.
- **Картинка.** В этом случае Body будет содержать описание этой картинки (например, сгенерированное LLM), а
  прикреплённая картинка будет источником для этого документа.
- **JSON-файл.** В этом случае Body будет содержать этот JSON, отформатированный в удобочитаемый вид (pretty print), а
  при включённой настройке "minimize before sending to LLM" отправляемый в LLM контекст будет содержать
  минимизированный JSON (minified) либо TOON.
- **Динамический источник**, который при выполнении или запросе к нему генерирует какой-то текстовый вывод, и этот вывод
  на этапе генерации контекста заменяет собой темплейт в Body документа (например "{{sql_response}}"), либо весь Body
  документ, если других источников у документа нет.

Все источники одного документа считаются продолжением друг друга, то есть они все вместе формируют единый Body
документа. Например:

- Если у документа несколько аудиофайлов, то считается, что это запись одной длинной встречи, которая разбита на
  несколько частей, и Markdown-текст документа будет содержать стенограммы всех этих частей.
- Если прикреплено несколько PDF-файлов, то считается, что это один документ, который состоит из нескольких PDF (
  например,
  главы одной книги).
- Если прикреплено несколько источников разных типов: аудио + PDF + картинка, то считается, что это встреча, в ходе
  которой обсуждался PDF-файл и была показана картинка.
- и т.д.

Источники могут быть прикреплены вручную к уже существующему документу, либо документ может быть создан на основании
одного или нескольких источников (вручную или автоматически). Например:

- Пользователь подключает устройство аудиозаписи (типа HiDock или диктофон в телефоне) и все его записи автоматически
  импортируются в HiDocu и превращаются в Sources. Далее на основании каждого Source может быть сгенерирован
  документ (на основании одного Source генерируется один документ). Пользователь затем может объединить несколько
  документов в
  один, если считает, что эти записи относятся к одной встрече. В этом случае Body итогового документа будет содержать
  стенограммы всех этих записей, а прикреплённые аудиофайлы будут считаться источниками для этого итогового документа.
- Также приложение HiDocu может быть интегрировано с календарём и автоматически создавать документ для каждой встречи в
  календаре (если для неё есть аудиофайл либо пользователь создал документ вручную из календарного события в интерфейсе
  календаря), а аудиофайл с записью этой встречи прикреплять к этому документу как источник. В этом случае Body
  документа будет содержать стенограмму этой встречи, а прикреплённый аудиофайл будет источником для этого документа.

### Recording as Source

Recording — это один из видов Source, который представляет собой аудиофайл с записью встречи или голосовой заметки.
Важно понимать, что Recording в большинстве случаев будет импортироваться автоматически и пользователь ожидает, что на
основании этого Recording будет автоматически создан документ со стенограммой этой встречи + Summary, и этот документ
будет
помещён в правильную папку (например, папку с 1:1s с John, если участником встречи является John). В то же время
пользователь должен иметь возможность
в любой момент вмешаться в этот процесс и изменить результат: например, если документ был помещён не в ту папку, то
пользователь может переместить его в другую папку; если стенограмма была сгенерирована с ошибками, то пользователь может
отредактировать её и т.д. Все действия, произведённые автоматически *до* проверки пользователем, не должны коммититься в
git, чтобы пользователь мог легко откатить эти действия, если результат его не устроил, и чтобы избежать ситуации, когда
sensitive-данные, принадлежащие к одному проекту или папке, случайно оказываются закоммиченными и видны в истории git
другой папки или проекта, к которому эти данные не относятся.

Recording имеет свои уникальные свойства или поддокументы:

- Filename
- Duration
- Started At
- Finished At
- Audio Format
- Size
- Transcripts — один или несколько вариантов транскрипта для этого Recording, сделанных с помощью разных моделей или с
  разными настройками. Один из вариантов транскрипта может быть помечен как Primary и копируется в
  Body документа. Выбор Primary-транскрипта может осуществляться с помощью LLM-Judge и/или может быть изменён
  пользователем в любой момент, и тогда Body документа будет обновлён на соответствующий транскрипт (пользователь должен
  быть уведомлён, что при этом все его правки в Body будут потеряны, но только в случае если такие правки были т.е. body
  должен быть помечен как "edited").

Типичный workflow для Recording как Source:

1. **Импорт аудиофайлов** и создание Source для каждого аудиофайла (с созданием соответствующих папок с расширением
   `.source`
   и файлов в них). Способы импорта одного или нескольких аудиофайлов могут быть разными:
    - Основной способ: пользователь подключает устройство аудиозаписи (такое как HiDock или аналог), и новые записи
      автоматически импортируются.
    - Альтернативно новые записи могут автоматически импортироваться из iPhone (какого-либо поддерживаемого приложения
      для аудиозаписи на iPhone).
    - Из облачного хранилища, например из iCloud или Dropbox, если пользователь сохраняет свои записи там.
    - Из локальной папки на компьютере, которую пользователь указал в настройках HiDocu как папку для аудиозаписей, и
      HiDocu периодически сканирует эту папку на наличие новых аудиофайлов и импортирует их.
    - Либо пользователь может вручную добавлять записи в HiDocu, например, перетаскивая аудиофайлы в интерфейс HiDocu.
2. **Анализ файла и сбор метаданных**: HiDocu извлекает метаданные из аудиофайла, его названия и/или creation
   time (например, дату и время записи, продолжительность, формат и т.п.) и сохраняет эти метаданные в базе данных и в
   файле `metadata.yaml` внутри папки этого Source.
3. **Создание документа (Document)**:
    - Если запись относится к промежутку времени, попадающему на календарное событие, то:
        - В случае если на основании календарного события уже существует документ, то эта запись прикрепляется к этому
          документу как Source. Существующий документ мог быть создан пользователем вручную, либо автоматически при
          обработке *другого* аудиофайла, относящегося к этому же календарному событию.
        - Если такого документа еще нет, то он автоматически создаётся, а Recording и календарное событие прикрепляются
          к этому документу как Source.
    - Если запись не относится к какому-либо календарному событию, то создаётся пустой документ, и эта запись
      прикрепляется к этому документу как Source.
4. **Предварительная сортировка**:
    - Если на основании правил документ можно отнести к какой-то папке (например, на основании данных календарного
      события, участников встречи и т.п.), то документ автоматически помещается в эту папку.
    - Если по правилам невозможно однозначно определить папку, то делается черновая стенограмма этой записи (например, с
      помощью локальной модели или быстрой и дешёвой модели, в настройках определённой как default draft transcription
      model), и на основании этой стенограммы и categorization context *всех* папок LLM-Judge определяет, к какой папке
      этот документ относится, и приложение помещает его в эту папку. Например, если в стенограмме встречаются имена
      John и Sarah, то LLM-Judge может определить, что эта встреча относится к папке "1:1s with John" или "1:1s with
      Sarah". Если в стенограмме встречаются термины, связанные с проектом Artemis и эти же термины присутствуют в
      categorization context соответствующей папки, то LLM-Judge может определить, что эта встреча
      относится к папке "Project Artemis".
    - Если даже LLM-Judge не может однозначно определить папку, то документ помещается в папку "Uncategorized", откуда
      пользователь может потом переместить его в нужную папку. Шаги «Генерация чистовой стенограммы», «Выбор лучшей
      стенограммы» и «Перенос Primary-транскрипта в Body документа» в этом случае пропускаются, а черновая
      стенограмма сохраняется в Body документа, чтобы пользователь мог прочитать её и понять, о чём эта встреча, и на
      основании этого переместить документ в нужную папку.
5. **Генерация чистовой стенограммы.** Т.к. настройки для генерации «чистовой» стенограммы могут отличаться от папки к
   папке, генерация чистовой стенограммы происходит уже после того, как документ помещён в папку, чтобы использовать
   настройки этой папки для генерации стенограммы:
    - Конфигурация одной папки может быть настроена на использование SOTA-модели для генерации стенограммы, а другая
      папка может быть настроена на использование только локальной модели из-за privacy-требований и т.п.
    - Также разные папки могут иметь разный transcription context, который будет использоваться для генерации
      стенограммы. Например, папка "Company X" может иметь общий контекст для транскрипции в виде доменной терминологии
      или списка сотрудников компании с их ролями и контактами, который будет использоваться для более точной
      транскрипции всех аудиозаписей в этой папке и во всех её вложенных папках.
    - В большинстве случаев приложение будет создавать 3 варианта транскрипта, но пользователь может настроить для
      каждой конкретной папки, сколько вариантов транскрипта он хочет (от 1) и с какими моделями или настройками. Бывают
      случаи, когда даже SOTA-модели галлюцинируют или опускают части стенограммы. В этих случаях полезно иметь
      несколько вариантов транскрипта, чтобы выбрать из них лучший, а не полагаться на один транскрипт, который может
      содержать ошибки.
6. **Выбор лучшей стенограммы.** Для выбора лучшей стенограммы HiDocu использует LLM-Judge, который на основании
   определённых критериев (например, полнота, отсутствие галлюцинаций и т.п.) выбирает лучший транскрипт из всех
   сгенерированных транскриптов для этого документа. Пользователь может в любой момент изменить выбор лучшей
   стенограммы, если он видит, что LLM-Judge выбрал не лучший транскрипт, и тогда Body документа будет обновлён на
   соответствующий транскрипт. Если была сгенерирована только одна стенограмма, то она автоматически становится Primary.
7. **Перенос Primary-транскрипта в Body документа.** Body документа обновляется на выбранный Primary-транскрипт, чтобы
   этот
   транскрипт формировал контекст для этого документа, который будет использоваться при общении с LLM.
8. **Генерация Summary.** На основании Body документа генерируется Summary, который сохраняется в отдельном
   markdown-файле и
   в базе данных для удобства отображения в UI. Для генерации Summary может использоваться другая модель, чем для
   генерации стенограммы.
9. **Пользователь видит новый документ** — один из вариантов:
    - Если документ был помещён в правильную папку, то пользователь видит этот документ в этой папке, помеченный как
      новый (непроверенный).
    - Если документ был помещён в папку "Uncategorized", то пользователь видит этот документ в папке "Uncategorized" и
      может
      открыть его, прочитать черновую стенограмму и понять, о чём эта встреча, и на основании этого переместить документ
      в нужную папку. При перемещении в нужную папку, если настройки этой папки отличаются от "Uncategorized", может
      запуститься процесс генерации новой чистовой стенограммы, выбора лучшей стенограммы и обновления Body документа,
      чтобы использовать настройки новой папки. Пользователь может отключить эту автоматическую генерацию новой
      стенограммы при перемещении документа.
    - В обоих случаях документ виден в папке "All Documents" в самом верху, потому что документы в этой папке по
      умолчанию
      сортируются по дате создания и новый документ всегда будет вверху. Это сделано для того, чтобы пользователь мог
      легко заметить новый документ, даже если он был помещён не в ту папку, и мог открыть его и понять, что это за
      документ, и на основании этого переместить его в нужную папку. Там он тоже
      помечается как новый (непроверенный), чтобы пользователь мог легко его заметить.
    - В любом случае документ не коммитится в git до тех пор, пока пользователь не проверит его и не подтвердит, что он
      готов к коммиту, чтобы избежать ситуации, когда sensitive-данные, принадлежащие к одному проекту или папке,
      случайно оказываются закоммиченными и
      видны в истории git другой папки или проекта, к которому эти данные не относятся. Пользователь может проверить
      документ, перенести в другую папку, и когда будет уверен, что документ на своём месте, он может нажать
      кнопку «Approve Folder» внутри документа.

#### Источники аудиозаписей (recording_sources и recording_devices)

Источниками аудиозаписей могут быть разные устройства и приложения для аудиозаписи, которые пользователь использует для
записи своих встреч и заметок. Например:

- HiDock (H1, H1E, P1, P1 Mini) — при подключении к компьютеру эти устройства могут автоматически импортироваться в
  HiDocu и превращаться в Sources.
- Диктофон в iPhone — если пользователь сохраняет свои записи в приложении "Voice Memos" на iPhone, то HiDocu может быть
  интегрирован с iCloud и автоматически импортировать эти записи в виде Sources.
- Другие приложения для аудиозаписи на iPhone — если эти приложения поддерживают синхронизацию с iCloud или Dropbox, то
  HiDocu может быть интегрирован с этими облачными хранилищами и автоматически импортировать записи из этих приложений в
  виде Sources.
- Локальная папка на компьютере — если пользователь сохраняет свои аудиозаписи в определённой папке на компьютере, то
  HiDocu может периодически сканировать эту папку на наличие новых аудиофайлов и автоматически импортировать их в виде
  Sources.

Известные устройства, для которых есть драйвер определяются автоматически при подключении. Остальные источники
конфигурируются пользователем в настройках.

При первом подключении нового устройства автоматический импорт не запускается. Когда пользователь подтверждает
использование устройства или меняет его настройки (например, включает авто-импорт), конфигурация этого устройства (ID,
название, правила) сохраняется в файл settings.yaml. База данных лишь отражает текущее состояние конфига и хранит
временные метки последней синхронизации (last_scan_at).

Так же Recordings будут связаны с конкретным устройством или источником, с которого они были импортированы, через
метаданные, чтобы пользователь мог видеть, откуда была сделана эта запись, и при необходимости фильтровать записи по
устройствам/источникам.

### Calendar Event as Source

Calendar Event — это ещё один вид Source, который представляет собой событие из календаря. В отличии от Recording,
Calendar Event самостоятельно не является триггером к автоматическому созданию документа, но может служить
дополнительным источником для документа, который был создан (или создается) на основании связанного с этим событием
Recording. Например, если есть аудиозапись встречи, которая была
автоматически связана с календарным событием, то это календарное событие может быть прикреплено к документу как Source и
будет добавлено в Body документа в виде информации о дате/времени ивента, списке участников, деталях встречи (например,
описании из календаря) и т.п. Это позволяет обогатить контекст документа дополнительной информацией из календаря,
которая может быть полезна при общении с LLM.

Пользователь может вручную из интерфейса календаря создать документ на основании календарного события, и в этом случае
это календарное событие будет Source для этого документа, а Body документа будет содержать информацию об этом событии из
календаря. Далее, если у пользователя нет аудиозаписи этой встречи, он может вручную добавить текстовую заметку или
любой другой дополнительный Source к этому документу, чтобы обогатить его контекст, а затем, когда у него появится
аудиозапись этой встречи, он может прикрепить эту аудиозапись к этому документу как Source, и тогда Body документа будет
обновлён на стенограмму этой встречи + информацию из календаря.

Для того чтобы это работало, приложение должно быть интегрирован с календарём или множеством календарей пользователя (
например, через CalDAV, iCloud API, Google Calendar API или аналогичные API для других календарей), чтобы получать
информацию о событиях в календаре и связывать эти события с аудиозаписями и документами. Информация об ивентах из
календарей должна периодически синхронизироваться в локальную базу данных чтобы приложение всегда имело актуальную
информацию о событиях в календаре для правильного связывания с аудиозаписями и документами. В том числе непосредственно
перед обработкой нового аудиофайла выполняется принудительная синхронизация всех календарей, чтобы иметь максимально
актуальную информацию о событиях в календаре для правильного связывания с этим аудиофайлом.

### X as Source

Все прочие источники (кроме Recording и Calendar Event) не могут автоматически создавать документ, а только
прикрепляться
к уже существующему документу. Это ограничение сделано для того, чтобы упростить flow определения папки для документа,
так как определение папки важно сделать до того, как обработать источник. Например, для картинки или PDF могут
использоваться LLM для анализа их контента, а настройки этих LLM могут отличаться от папки к папке.

Общее правило для таких источников: перевести их в текстовый вид (например, PDF в текст с помощью OCR, картинку в
описание с помощью LLM, JSON в pretty print или minified вид и т.п.), сохранить этот текст в Body документа, а сам файл
прикрепить к этому документу как источник.

### Динамические источники

Динамические источники — это источники, которые при выполнении или запросе к ним генерируют какой-то текстовый вывод, и
этот вывод сохраняется в Body документа.

Триггером для вызова источника и обновления может быть открытие документа пользователем, этап подготовки контекста
для отправки в LLM, либо ручное нажатие пользователем кнопки «Обновить».

Примеры таких динамических источников:

- Shell-команда, которая выполняется в sandboxed-окружении и генерирует какой-то текстовый вывод, и этот вывод
  сохраняется в Body документа, а сама команда является источником для этого документа. Пользователь может разрешить
  выполнение shell-команд не в sandboxed-окружении, только на уровне настроек всего приложения, если он доверяет этим
  командам и хочет, чтобы они имели доступ к его файловой системе, БД и т.п.
- API-запрос, который при выполнении генерирует какой-то текстовый вывод, и этот вывод сохраняется в Body
  документа, а сама команда является источником для этого документа.
- Google Docs или Notion документ, который при запросе к нему конвертируется в Markdown-текст и сохраняется в Body
  документа, а ссылка на этот документ является источником для этого документа.
- Git-/GitHub-репозиторий, который при запросе к нему конвертируется в Markdown-текст с помощью repomix.
- Запрос к БД.
- Запрос к другой LLM.

### Approval workflow

После автоматической сортировки документов по папкам они остаются в статусе "непроверенных" (unapproved) до тех пор,
пока пользователь не проверит их и не подтвердит, что они определены в правильную папку. Пользователь может это сделать
внутри документа, нажав кнопку «Approve Folder», либо на группе документов, нажав кнопку «Approve All in Folder», и
тогда все документы в этой папке, которые находятся в статусе "непроверенных", будут подтверждены. Это сделано для того,
чтобы избежать ситуации, когда sensitive-данные, принадлежащие к одному проекту или папке, случайно оказываются
закоммиченными и видны в истории git другой папки или проекта, к которому эти данные не относятся, из-за ошибки в
автоматической сортировке.

После того как документ был подтверждён, он коммитится в git, и его статус меняется на "проверенный" (approved).

Если пользователь перемещает непроверенный документ или группу документов из одной папки в другую, то считается что
пользователь проверил правильность их расположения (переместив в нужное место) и они автоматически
становятся проверенным и сразу после перемещения коммитится в git отдельным коммитом, но в течение 10 секунд еще не
запускают действия по генерации новой стенограммы, или push в удалённый репозиторий, чтобы пользователь мог отменить
этот коммит и переместить документ обратно, если он случайно переместил его не в ту папку.

## Folder

Folder — это способ организации документов. Folder может содержать документы и другие папки. Folder может быть
использован для формирования контекста. Folder может представлять собой компанию, проект, категорию, тему, клиента,
сотрудника и т.п. Например, папка "1:1s with John" может содержать все документы-стенограммы встреч с John и личные
заметки по этим встречам, папка "Project Artemis" может содержать все документы, связанные с этим проектом: планы,
задачи, документацию, стенограммы встреч по этому проекту и т.п., папка "Goals and OKRs" может содержать документы с
целями и ключевыми результатами компании и т.п.

Пример иерархии папок и документов:

- Company X
    - 1:1s:
        - 1:1s with John (содержит документы-стенограммы всех встреч с John и личные заметки по этим встречам)
        - 1:1s with Sarah
    - Project Artemis (содержит документы, связанные с этим проектом: планы, задачи, документацию, стенограммы встреч по
      этому проекту и т.п.)
    - Goals and OKRs
        - Objective 1
            - Sub Objective 1.1
            - Sub Objective 1.2
        - Objective 2
        - Objective 3
- My Startup
    - Hiring
        - Position A
            - Candidate 1 (содержит документы-стенограммы всех интервью с этим кандидатом и заметки по этим интервью)
            - Candidate 2
        - Position B
    - Vibe-coding (документы с исходным кодом, architecture decisions и т.п.)
- Personal
    - Health
        - Doctor Visits (документы-стенограммы всех визитов к врачу и заметки по этим визитам)
        - Workout Routines
        - Therapy Sessions
    - Finances
        - Budget 2026
        - Investment Research

Те же папки в ASCII-виде:

```
/
├── Company X/
│   ├── 1:1s/
│   │   ├── 1:1s with John/
│   │   │   └── (стенограммы всех встреч с John + личные заметки)
│   │   └── 1:1s with Sarah/
│   ├── Project Artemis/
│   │   └── (планы, задачи, документация, стенограммы встреч и т.п.)
│   └── Goals and OKRs/
│       ├── Objective 1/
│       │   ├── Sub Objective 1.1/
│       │   └── Sub Objective 1.2/
│       ├── Objective 2/
│       └── Objective 3/
│
├── My Startup/
│   ├── Hiring/
│   │   ├── Position A/
│   │   │   ├── Candidate 1/
│   │   │   │   └── (стенограммы интервью + заметки)
│   │   │   └── Candidate 2/
│   │   └── Position B/
│   └── Vibe-coding/
│       └── (исходный код, architecture decisions и т.п.)
│
└── Personal/
├── Health/
│   ├── Doctor Visits/
│   │   └── (стенограммы визитов + заметки)
│   ├── Workout Routines/
│   └── Therapy Sessions/
│
└── Finances/
├── Budget 2026/
└── Investment Research/
```

Папка может содержать дополнительные настройки:

- **Контекст для транскрипции (transcription context)**: например, папка "Company X" может иметь общий контекст для
  транскрипции в виде доменной терминологии или списка сотрудников компании с их ролями и контактами, который будет
  использоваться для более точной транскрипции всех аудиозаписей в этой папке и во всех её вложенных папках. Это
  позволяет улучшить качество транскрипции за счёт предоставления LLM дополнительного контекста о том, какие термины и
  имена могут использоваться в этих записях.
- **Правила автоматической организации документов**: например, все документы, созданные на основании ивента из рабочего
  календаря, должны автоматически помещаться в папку "Company X". Если участником этого ивента
  является John и название содержит "1:1", то документ должен помещаться в папку "Company X/1:1s/1:1s with John".
- **Контекст для автоопределения папки для новых документов (categorization context)**. В случае если документ нельзя
  отнести к какой-либо папке на основании правил автоматической организации, можно использовать контекст для
  автоопределения папки с помощью LLM. Например, после автоматического импорта аудиофайла с устройства автоматически
  создаётся документ на основании этого файла, далее аудиофайл транскрибируется, и на основании транскрипта LLM
  определяет, к какой папке отнести этот документ: приложение отдаёт в LLM транскрипт и список всех папок и их
  categorization contexts, и LLM возвращает наиболее релевантную папку для этого документа.

Настройки наследуются от родительской папки, но могут быть переопределены или дополнены (выбирается пользователем) на
уровне вложенной папки.

Приложение также должно содержать системные папки:

- **"All Documents"** — виртуальная папка, которая показывает все документы без фильтрации, отсортированные от самых
  новых к
  самым старым. Это просто представление всех документов в виде списка, и она не влияет на структуру папок и документов.
  Удобно для быстрого доступа ко всем документам, поиска и быстрого обзора того, какие документы были добавлены
  недавно (например, после синхронизации с устройством).
- **"Uncategorized"** — для документов, которые не были отнесены пользователем ни к одной папке. Содержимое этой папки
  не
  версионируется в git и хранится отдельно от git-репозиториев, т.к. мы не знаем заранее, к какому именно
  git-репозиторию
  эти документы относятся, и не хотим случайно внести эти документы в историю неправильного репозитория, т.к. история
  git
  является общедоступной и immutable, и это критично для sensitive-данных. Пользователь может перемещать документы из
  папки "Uncategorized" в другие папки и обратно. В эту папку будут попадать все новые документы, которые
  были автоматически созданы на основании новых источников (например, новых аудиозаписей с подключённых устройств) и для
  которых не удалось автоматически определить папку (например, на основании календаря или контекста источника). Если
  пользователь удаляет
  документ из папки "Uncategorized", то он удаляется в local trash.
- **"Trash"** — для удалённых документов. Формируется на основании истории git за последние 30 дней + local_trash.
  Для git-составляющей показываются документы, которые были удалены за последние 30 дней. Пользователь может
  восстановить документ из папки "Trash". Копия истории удаления хранится в БД для ускорения и удобства отображения в
  UI, но для файлов удаленных будучи в git первоисточник истины — это история git, а для local_trash - папка trash,
  которые могут быть реиндексированы в случае повреждения БД.

### Правила автоматической организации (sorting/categorization rules)

Пользователь может настроить правила автоматической организации документов в папки. Например:

- Все документы, созданные на основании ивента из рабочего календаря, должны автоматически помещаться в папку "Company
  X".
- Если участником этого ивента является John и название содержит "1:1", то документ должен помещаться в папку "Company
  X/1:1s/1:1s with John".

Пользователь может использовать if (условия) и then (папка). При этом условия могут быть сложными, сочетающими несколько
параметров в режиме И (AND) или ИЛИ (OR) или в миксе. Например:

```
if (event_participants contains John AND event_title contains "1:1") OR (transcript contains "John" AND transcript contains "1:1") then folder is "Company X/1:1s/1:1s with John"
```

Правила хранятся в yaml-файлах внутри папок, и при индексации git-репозитория приложение сохраняет эти правила в единую
таблицу в базе данных для удобства и скорости применения этих правил при автоматической организации документов.
Приложение поддерживает актуальность правил в БД: если пользователь изменил правило в yaml-файле, то приложение должно
обновить это правило в БД; если пользователь удалил правило, то приложение должно удалить это правило из БД; если
пользователь удал папку, то приложение должно удалить все правила, которые были определены в этой папке и во всех её
вложенных папках, из БД.

### LLM-Judge (LLM-Судья)

**LLM-Judge** — это механизм использования LLM для оценки и принятия решений, а не для генерации контента. В частности
приложение может использовать LLM-Judge для:

- Выбора лучшей стенограммы из нескольких вариантов
- Определения, к какой папке отнести новый документ на основании его контента
  Для этого может использоваться как более "умная" и дорогая модель (например, Gemini 3 Pro, Claude Opus), так локальная
  модель, в зависимости от настроек папки и требований к приватности. В любом случае, для LLM-Judge используются заранее
  заготовленные системные промпты, которые пользователь может донастроить в расширенных настройках папки.

В приложении используются заранее заготовленные системные промпты для Judge, которые пользователь может донастроить в
расширенных настройках.

Пример шаблона промпта для выбора лучшей стенограммы из 3х вариантов (может изменяться, если вариантов стенограммы
больше или меньше 3х):

```
Compare 3 transcripts:

1:
<Transcript 1>

2:
<Transcript 2>

3:
<Transcript 3>

One of them is odd, may contain mistakes, hallucinations or have some information missing or wrongly identified speakers.
Which one is odd?
And which one is the best?

Respond in the following JSON format:
{
"reason": "explanation of why the odd transcript is odd and why the best transcript is the best",
"oddTranscript": 1, // number of the odd transcript
"bestTranscript": 2 // number of the best transcript
}
```

Пример шаблона промпта для определения папки для нового документа на основании его контента:

```We have a new document with the following content:
<Document Transcript>

We have the following folders with their categorization contexts:
| id | folder_name | categorization_context |
| 1 | 1:1s with John | Keywords: John, 1:1, Meeting, Sync |
| 2 | 1:1s with Sarah | Keywords: Sarah, 1:1, Meeting, Sync |
| 3 | Project Artemis | Keywords: Artemis, Project, Task, Deadline |
| 4 | Uncategorized | (empty) |

Based on the content of the document, which folder is the most relevant for this document?
If unclear, choose "Uncategorized" folder.

Respond in the following JSON format:
{
  "reason": "explanation of why this folder is the most relevant for this document",
  "folder_name": "1:1s with John", // name of the most relevant folder
  "folder_number": 1 // number of the most relevant folder
}
```

## Transcription Context

Transcription Context - это дополнительный контекст, который может быть использован для генерации стенограммы на
основании аудиозаписи. Он может включать в себя доменную терминологию, список сотрудников компании с их ролями и
контактами, список проектов и т.п. Этот контекст может быть определён для каждой папки и будет использоваться для
генерации стенограммы всех аудиозаписей, которые находятся в этой папке и во всех её вложенных папках.

Определяя Transcription Context для дочерней папки, пользователь может указать, что он хочет добавить этот контекст к
контексту родительской папки или переопределить его, то есть не использовать контекст родительской папки, а использовать
только этот контекст для генерации стенограммы аудиозаписей в этой папке и её вложенных папках.

Для чего может использоваться *дополнение* родительского Transcription Context: например, папка "Company X" может иметь
общий контекст для транскрипции в виде доменной терминологии, а папка "Project Artemis" может дополнять этот контекст
списком терминов, связанных с этим проектом, чтобы эти термины использовались для более точной транскрипции всех
аудиозаписей в папке "Project Artemis" и во всех её вложенных папках.

Transcription Context так же может формироваться или обогощаться динамически на основании шаблонов и запросов во внешние
источники,
например список сотрудников компании с их ролями и контактами может формироваться на основании запроса к БД сотрудников
компании, и тогда этот список будет автоматически обновляться при каждом запросе к этому источнику, чтобы в
транскрипции всегда использовалась актуальная информация о сотрудниках компании.

Пример шаблона для динамического Transcription Context для папки "Company X", который формирует список сотрудников
компании с их ролями и
контактами на основании запроса к БД сотрудников компании:

```markdown
Domain Terminology:

- KPI
- OKR
- ROI
- API

Employees:
{{employee_list}}
```

При этом есть отдельное место в настройках папки, где пользователь может указать, как формировать `employee_list` на
основании запроса к БД или к API или вызовом shell-команды и т.п., и этот `employee_list` будет автоматически
обновляться при каждом запросе к этому источнику, чтобы в транскрипции всегда использовалась актуальная информация о
сотрудниках компании. Так же можно включить кеширование для этого источника, чтобы не делать запрос к БД или API при
каждом запросе к этому документу, а делать его, например, раз в день, и сохранять результат этого запроса в базе данных.

Пример статического или скомпилированного из динамического Transcription Context для папки "Company X":

```markdown
Domain Terminology:

- KPI
- OKR
- ROI
- API

Employees:

- John Doe, CEO
- Sarah Smith, CTO
- Bob Johnson, Product Manager

Projects:

- Project Artemis
- Project Apollo
- Frontend: React, TypeScript
- Backend: Node.js, Express, MongoDB
- Repository: github.com/company-x/project-artemis
```

## Categorization Context

Categorization Context — это дополнительный контекст, который может быть использован для автоматической категоризации
новых документов на основании их контента. Он по своей структуре аналогичен Transcription Context, но используется для
другой цели: для определения папки, к которой относится новый документ, на основании его контента.

Пример Categorization Context для папки "1:1s with John", который может использоваться для определения, относится ли
новый
документ к этой папке на основании его контента:

```markdown
Keywords:

- John
- 1:1
- Meeting
- Sync
```

Далее этот контекст может использоваться LLM-Judge для определения, относится ли новый документ к папке "1:1s with John"
на
основании его контента (см LLM-Judge).

## Работа с git

Git является первоисточником истины для всех документов (кроме динамических) и их версий и метаданных, а также
конфигураций папок и всего что они содержат. База данных — это просто кэш для удобства отображения в UI и ускорения
доступа к
данным. В случае повреждения или удаления базы данных все документы и их версии могут быть восстановлены на основании
истории git. Первоисточники метаданных документов, источников (Sources) и т.п. (название, дата создания и т.п.) хранятся
в виде
отдельных «специальных» файлов в git. Бинарные файлы источников (аудиофайлы, PDF и
т.п.) хранятся либо в git LFS, либо в локальной папке вне git-репозитория, которая может быть синхронизирована с
помощью облачного хранилища (iCloud, Dropbox, S3 и т.п.).

Приложение должно уметь работать с git-репозиторием, который хранится локально на диске либо удалённо (например, на
GitHub).

Приложение должно коммитить изменения документов и конфигураций в git, а также периодически синхронизироваться с
удалённым репозиторием, если он настроен. Синхронизация должна быть двунаправленной: изменения из удалённого репозитория
должны подтягиваться в приложение. Полученные изменения должны применяться точечно: то есть если из удалённого
репозитория пришёл новый документ, то он должен быть добавлен в базу данных и отображён в UI, но при этом не должно быть
полной переиндексации всех документов и папок, так как это может быть очень дорого по ресурсам и времени. Аналогично,
если пользователь создал новый документ или папку, то это изменение должно быть закоммичено в git и синхронизировано с
удалённым репозиторием, но при этом не должно быть полной переиндексации всех документов и папок. Синхронизация должна
происходить в фоне и не должна блокировать UI. В случае конфликтов при синхронизации приложение должно предлагать
пользователю удобный интерфейс для разрешения конфликтов, который позволяет сравнить изменения и выбрать, какие
изменения
оставить, а какие откатить, либо целиком принять remote- или local-версию файла.

Папки или подпапки могут представлять собой вложенные git-репозитории по аналогии с git submodules. Например, папка
"Project Artemis" может быть суб-репозиторием внутри репозитория "Company X". Важно избежать использования git
submodules, так как они создают сложности в управлении и синхронизации: лишние коммиты в родительском репозитории при
изменении субмодуля и сложность в отслеживании изменений в субмодулях, подключённых к нескольким родительским
репозиториям. Вместо этого в корневой папке родительского репозитория (например, "Company X") будет храниться
конфигурационный файл, который указывает, какие папки являются суб-репозиториями и к каким удалённым репозиториям они
подключены.

После автоматического импорта и создания новых документов (например, на основании импортированной аудиозаписи) они не
коммитятся в git автоматически, давая пользователю
возможность проверить, правильно ли они были категоризированы и правильно ли они были отнесены к тому или иному
git-репозиторию. Такие документы отдельно подсвечиваются в UI, чтобы пользователь мог их легко найти и проверить. После
проверки пользователь может вручную закоммитить эти документы в git, либо переместить, либо удалить до того, как они
попали в immutable-историю git.

Пользователь может отказаться от работы с git и использовать HiDocu только с локальной файловой системой и базой данных,
без версионирования документов. В этом случае документы будут храниться в виде файлов на диске так же, как они хранились
бы в git. Пользователь может в любой момент подключить папку к новому или уже существующему git-репозиторию, и все
документы из этой папки будут добавлены в этот репозиторий и закоммичены, а дальнейшие изменения будут
синхронизироваться с этим репозиторием.

## Conflict Resolution UI

Интерфейс решения конфликтов синхронизации (когда файл изменен и локально, и на сервере).

* **Для Markdown (Body/Summary):** Используется **3-way merge** визуальный редактор. Показывается: "Ваша версия", "
  Версия сервера" и "Результат". Изменения подсвечиваются.
* **Для Metadata (YAML):** Автоматическое слияние, если ключи разные. Если изменен один и тот же ключ — пользователю
  предлагается выбрать значение.

## Хранение бинарных файлов (Git LFS vs Local Sync)

Пользователь выбирает стратегию хранения для папки `sources` (где лежат тяжелые аудиофайлы):

* **Git LFS:** Если у пользователя есть сервер с поддержкой LFS (GitHub/GitLab) и достаточная квота. Файлы хранятся в
  `.git/lfs` и ссылаются через pointer files.
* **External Folder (через .link файлы):** (Рекомендуемый режим для personal use). Аудиофайлы хранятся в обычной папке (
  напр., `~/Dropbox/HiDocu_Audio/`), а внутри `.document` создается текстовый файл-ссылка (`.link`), указывающий на
  путь к файлу. Это позволяет синхронизировать текстовые заметки через Git (бесплатно и быстро), а тяжелое аудио — через
  Dropbox/iCloud, не раздувая Git-репозиторий.

## Glossary & Technical Specifics (Глоссарий и Технические детали)

### TOON (Token-Optimized Object Notation)

**TOON** — это формат сериализации данных, разработанный специально для снижения расхода токенов при общении с LLM. В
отличие от JSON, который требует большого количества синтаксического шума (кавычки, фигурные скобки, повторяющиеся ключи
в массивах объектов), TOON использует отступы и заголовочные структуры (header-based arrays), чтобы передать ту же
структуру данных с использованием на 30-50% меньшего количества токенов.

### Repomix

**Repomix** (ранее известный как `repopack`) — это утилита для упаковки содержимого кодового репозитория (или любой
папки с файлами) в единый текстовый файл (обычно XML или Markdown), оптимизированный для понимания LLM.

## Database (SQLite)

HiDocu использует **SQLite** в качестве локальной базы данных. БД является **кэшем** для ускорения доступа к данным и
удобства отображения в UI. **Первоисточником истины** для всех документов, метаданных, конфигураций и версий является *
*git-репозиторий** (и файловая система для uncategorized-документов и бинарных файлов вне git). В случае повреждения или
удаления БД все данные могут быть полностью восстановлены путём реиндексации файлов из git и файловой системы.

### Принципы

- **Cache, not source of truth.**  БД можно удалить и пересоздать без потери данных. Любая
  запись в БД должна быть воспроизводима из файлов на диске. Документы восстанавливаются из Git/файловой системы.
  Конфигурация приложения, список подключенных устройств и календарей восстанавливаются из файла settings.yaml.
  Runtime-состояния (например, sync_token календаря или last_scan_at устройства) могут быть потеряны при удалении БД, но
  это приведет лишь к одной полной синхронизации/сканированию вместо инкрементальной, что допустимо для кэша.
- **Быстрый доступ к метаданным.** Чтение `metadata.yaml` каждого документа при каждом открытии списка папок неприемлемо
  по производительности. БД кэширует метаданные для мгновенного отображения в UI.
- **Полнотекстовый поиск.** SQLite FTS5 используется для поиска по Body, Summary, названиям документов и метаданным
  источников.
- **Отслеживание статусов.** Approval status, статусы транскрипции и другие runtime-состояния, которые не хранятся в
  git, живут только в БД (и восстанавливаются при реиндексации на основании наличия/отсутствия коммита).
- **WAL mode.** БД работает в режиме WAL (Write-Ahead Logging) для обеспечения конкурентного чтения из UI-потока и
  записи из фоновых потоков (импорт, транскрипция, синхронизация с git).

### Расположение

```
~/Library/Application Support/HiDocu/
├── hidocu.db              # основная БД
├── hidocu.db-wal          # WAL-файл
├── hidocu.db-shm          # shared memory для WAL
└── backups/
    └── hidocu-2026-01-15.db   # автоматический бэкап перед миграциями
```

---

### Схема

#### `folders` — кэш папок

Системные папки ("All Documents", "Uncategorized", "Trash") захардкожены на уровне приложения и не хранятся в этой
таблице.

```sql
CREATE TABLE folders
(
    id                         TEXT PRIMARY KEY,                    -- UUID, стабильный идентификатор папки
    parent_id                  TEXT REFERENCES folders (id) ON DELETE CASCADE,
    name                       TEXT    NOT NULL,

    -- Git
    is_repo_root               INTEGER NOT NULL DEFAULT 0,          -- 1 если эта папка — корень git-репозитория

    -- Настройки (кэш из config.yaml папки)
    transcription_context_mode TEXT             DEFAULT 'extend',   -- 'extend' | 'override'
    categorization_context     TEXT,                                -- текст categorization context
    prefer_summary             INTEGER NOT NULL DEFAULT 0,          -- что использовать в контексте - summary или body
    minimize_before_llm        INTEGER NOT NULL DEFAULT 0,
    transcription_model        TEXT,                                -- модель для transcription
    transcription_variants     INTEGER                              -- сколько вариантов стенограммы генерировать, если NULL, то использовать глобальную настройку
        transcription_judge_model  TEXT,                            -- модель для LLM-Judge

    -- Бинарное хранилище
    binary_storage_strategy    TEXT             DEFAULT 'external', -- 'git_lfs' | 'external'
    external_storage_path      TEXT,                                -- путь к внешней папке (~/Dropbox/HiDocu_Audio/)

    -- Timestamps
    created_at                 TEXT    NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at                 TEXT    NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),

    -- Filesystem
    fs_path                    TEXT    NOT NULL                     -- абсолютный путь к папке на диске
);

CREATE INDEX idx_folders_parent ON folders (parent_id);
```

#### `sorting_rules` — правила автоматической организации

```sql
CREATE TABLE sorting_rules
(
    id             TEXT PRIMARY KEY,
    folder_id      TEXT    NOT NULL REFERENCES folders (id) ON DELETE CASCADE,
    priority       INTEGER NOT NULL DEFAULT 0, -- порядок применения (меньше = выше приоритет)
    condition_expr TEXT    NOT NULL,           -- выражение условия в DSL или JSON
    -- Примеры condition_expr:
    -- '{"and": [{"field": "event_participants", "op": "contains", "value": "John"}, {"field": "event_title", "op": "contains", "value": "1:1"}]}'
    is_enabled     INTEGER NOT NULL DEFAULT 1,
    created_at     TEXT    NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now'))
);

CREATE INDEX idx_sorting_rules_folder ON sorting_rules (folder_id, priority);
```

#### `documents` — кэш документов

```sql
CREATE TABLE documents
(
    id                  TEXT PRIMARY KEY,                      -- UUID
    folder_id           TEXT    REFERENCES folders (id) ON DELETE SET NULL,

    -- Метаданные (кэш из metadata.yaml)
    title               TEXT    NOT NULL,
    document_type       TEXT    NOT NULL DEFAULT 'markdown',   -- 'transcript' | 'json' | 'markdown'
    created_at          TEXT    NOT NULL,
    updated_at          TEXT    NOT NULL,

    -- Approval workflow
    approval_status     TEXT    NOT NULL DEFAULT 'unapproved', -- 'unapproved' | 'approved'
    approved_at         TEXT,
    git_committed       INTEGER NOT NULL DEFAULT 0,            -- 1 если закоммичен в git
    last_commit_sha     TEXT,                                  -- SHA последнего коммита с этим документом

    -- Настройки документа (кэш из metadata.yaml)
    prefer_summary      INTEGER NOT NULL DEFAULT 0,            -- что использовать в контексте - summary или body
    minimize_before_llm INTEGER NOT NULL DEFAULT 0,

    -- Кэш контента
    body_preview        TEXT,                                  -- первые ~500 символов Body для отображения в списке
    summary_text        TEXT,                                  -- полный Summary (обычно короткий, удобно держать в БД)
    body_hash           TEXT,                                  -- SHA-256 хэш body.md для отслеживания изменений
    summary_hash        TEXT,                                  -- SHA-256 хэш summary.md

    -- Filesystem
    fs_path             TEXT    NOT NULL UNIQUE                -- абсолютный путь к .document папке на диске
);

CREATE INDEX idx_documents_folder ON documents (folder_id);
CREATE INDEX idx_documents_approval ON documents (approval_status);
CREATE INDEX idx_documents_created ON documents (created_at DESC);
CREATE INDEX idx_documents_type ON documents (document_type);
```

#### `document_token_cache` — кэш подсчёта токенов для документов

Подсчёт токенов зависит от модели (разные модели используют разные токенизаторы). Когда пользователь переключает
целевую модель (например, с GPT-4o на Claude), кэш для предыдущей модели остаётся валидным (пока не изменился контент),
а для новой модели пересчитывается при первом обращении.

```sql
CREATE TABLE document_token_cache
(
    document_id     TEXT    NOT NULL REFERENCES documents (id) ON DELETE CASCADE,
    body_tokens     INTEGER NOT NULL, -- токены в Body
    body_tokens_min INTEGER,          -- токены в минимизированном Body (NULL если minimize не включён)
    summary_tokens  INTEGER,          -- токены в Summary (NULL если Summary пуст)
    content_hash    TEXT    NOT NULL, -- SHA-256(body_hash + summary_hash) для инвалидации
    computed_at     TEXT    NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    PRIMARY KEY (document_id, tokenizer)
);
```

Инвалидация: при изменении `body_hash` или `summary_hash` в `documents` все строки `document_token_cache` для этого
документа становятся stale (content_hash не совпадает) и пересчитываются при следующем обращении (lazy).

#### `folder_token_cache` — агрегированный кэш токенов для папок/контекстов

Агрегат поверх `document_token_cache`. Хранит суммарное количество токенов для всего контекста папки.

```sql
CREATE TABLE folder_token_cache
(
    folder_id      TEXT    NOT NULL REFERENCES folders (id) ON DELETE CASCADE,
    tokenizer      TEXT    NOT NULL, -- тот же tokenizer что и в document_token_cache
    token_count    INTEGER NOT NULL, -- суммарное количество токенов всех документов в контексте
    document_count INTEGER NOT NULL, -- сколько документов включено в подсчёт
    content_hash   TEXT    NOT NULL, -- хэш от конкатенации content_hash всех документов, для инвалидации
    computed_at    TEXT    NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    PRIMARY KEY (folder_id, tokenizer)
);
```

#### `calendars` — кэш конфигурации календарей

Первоисточник: settings.yaml (секц. calendars.accounts). При старте приложения таблица синхронизируется с конфигом.

```sql
CREATE TABLE calendars
(
    id            TEXT PRIMARY KEY,             -- UUID (генерируется или берется из settings.yaml)

    -- Конфигурация (из settings.yaml)
    provider      TEXT    NOT NULL,             -- 'apple' | 'google' | 'caldav' | 'outlook'
    account_name  TEXT    NOT NULL,             -- "john@company.com" или "Work"
    calendar_name TEXT    NOT NULL,             -- "Work Calendar", "Personal"
    calendar_id   TEXT    NOT NULL,             -- внешний ID календаря из API провайдера
    color         TEXT,                         -- цвет календаря для UI (#FF5733)
    is_enabled    INTEGER NOT NULL DEFAULT 1,   -- 1 = синхронизировать этот календарь
    sync_interval INTEGER NOT NULL DEFAULT 900, -- интервал синхронизации в секундах (по умолчанию 15 мин)
    last_sync_at  TEXT,

    -- Runtime state (живёт только в БД, сбрасывается при удалении БД)
    sync_token    TEXT,                         -- incremental sync token (Google) или ctag (CalDAV)
    created_at    TEXT    NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    UNIQUE (provider, calendar_id)
);

CREATE INDEX idx_calendars_enabled ON calendars (is_enabled) WHERE is_enabled = 1;
```

#### `calendar_events` — кэш событий из календарей

```sql
CREATE TABLE calendar_events
(
    id              TEXT PRIMARY KEY,                     -- UUID внутренний
    calendar_id     TEXT    NOT NULL REFERENCES calendars (id) ON DELETE CASCADE,
    external_id     TEXT    NOT NULL,                     -- ID события из API провайдера
    title           TEXT    NOT NULL,
    description     TEXT,                                 -- описание события из календаря
    location        TEXT,
    start_at        TEXT    NOT NULL,                     -- ISO 8601
    end_at          TEXT    NOT NULL,                     -- ISO 8601
    is_all_day      INTEGER NOT NULL DEFAULT 0,
    status          TEXT             DEFAULT 'confirmed', -- 'confirmed' | 'tentative' | 'cancelled'
    organizer_email TEXT,
    organizer_name  TEXT,
    recurrence_id   TEXT,                                 -- для повторяющихся событий: ID серии

    -- Связь с документом
    document_id     TEXT    REFERENCES documents (id) ON DELETE SET NULL,

    -- Метаданные синхронизации
    etag            TEXT,                                 -- ETag для incremental sync
    raw_data        TEXT,                                 -- JSON с полными данными события для будущего использования
    last_sync_at    TEXT    NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),

    UNIQUE (calendar_id, external_id)
);

CREATE INDEX idx_calendar_events_time ON calendar_events (start_at, end_at);
CREATE INDEX idx_calendar_events_document ON calendar_events (document_id) WHERE document_id IS NOT NULL;
CREATE INDEX idx_calendar_events_calendar ON calendar_events (calendar_id);
```

#### `calendar_event_participants` — участники событий

```sql
CREATE TABLE calendar_event_participants
(
    id           TEXT PRIMARY KEY,
    event_id     TEXT    NOT NULL REFERENCES calendar_events (id) ON DELETE CASCADE,
    email        TEXT,
    display_name TEXT,
    status       TEXT             DEFAULT 'needs-action', -- 'accepted' | 'declined' | 'tentative' | 'needs-action'
    is_organizer INTEGER NOT NULL DEFAULT 0
);

CREATE INDEX idx_event_participants_event ON calendar_event_participants (event_id);
CREATE INDEX idx_event_participants_email ON calendar_event_participants (email) WHERE email IS NOT NULL;
```

#### `sources` — кэш источников

```sql
CREATE TABLE sources
(
    id                TEXT PRIMARY KEY,           -- UUID
    document_id       TEXT    NOT NULL REFERENCES documents (id) ON DELETE CASCADE,
    source_type       TEXT    NOT NULL,           -- 'recording' | 'calendar_event' | 'pdf' | 'image' | 'json' | 'dynamic_shell' | 'dynamic_api' | 'dynamic_gdocs' | 'dynamic_git' | 'dynamic_db' | 'other'
    display_name      TEXT,
    sort_order        INTEGER NOT NULL DEFAULT 0, -- порядок источников в документе

    -- Filesystem
    fs_path           TEXT    NOT NULL,           -- путь к .source папке
    binary_path       TEXT,                       -- путь к бинарному файлу (аудио/PDF/картинка), может быть .link
    binary_size       INTEGER,                    -- размер бинарного файла в байтах

    -- Связь с calendar_event (если source_type = 'calendar_event')
    calendar_event_id TEXT    REFERENCES calendar_events (id) ON DELETE SET NULL,

    -- Для динамических источников
    is_dynamic        INTEGER NOT NULL DEFAULT 0,
    dynamic_trigger   TEXT,                       -- 'on_open' | 'on_context_build' | 'manual'
    dynamic_command   TEXT,                       -- shell-команда, API-URL, и т.п.
    cache_ttl         INTEGER,                    -- TTL кэша в секундах, NULL = не кэшировать
    last_fetched_at   TEXT,                       -- когда последний раз обновлялись данные

    created_at        TEXT    NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at        TEXT    NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now'))
);

CREATE INDEX idx_sources_document ON sources (document_id, sort_order);
CREATE INDEX idx_sources_type ON sources (source_type);
CREATE INDEX idx_sources_calendar_event ON sources (calendar_event_id) WHERE calendar_event_id IS NOT NULL;
```

#### `audio_import_sources` — кэш известных устройств

Первоисточник: settings.yaml (секц. audio_import.devices). При подключении устройства запись добавляется в
settings.yaml, а затем реплицируется в эту таблицу.

Хранит все известные устройства и источники импорта аудио. Новое устройство добавляется при первом подключении, но
автоматический импорт не запускается, пока пользователь не подтвердит.

```sql
CREATE TABLE audio_import_sources
(
    id             TEXT PRIMARY KEY,           -- UUID

    -- Конфигурация (из settings.yaml)
    source_type    TEXT    NOT NULL,           -- 'hidock' | 'iphone_voice_memos' | 'iphone_app' | 'folder_watch' | 'icloud' | 'dropbox' | 'manual'
    display_name   TEXT    NOT NULL,           -- "HiDock H1 (SN: ABC123)" или "~/Recordings"
    device_model   TEXT,                       -- 'h1' | 'h1e' | 'p1' | 'p1_mini' | NULL для не-HiDock
    device_id      TEXT,                       -- уникальный идентификатор устройства (серийный номер, USB ID и т.п.)
    watch_path     TEXT,                       -- путь к папке для folder_watch / облачному хранилищу
    auto_import    INTEGER NOT NULL DEFAULT 0, -- 1 = импортировать автоматически при обнаружении новых файлов
    is_active      INTEGER NOT NULL DEFAULT 1, -- 0 = деактивирован пользователем

    -- Для отслеживания уже импортированных файлов
    -- Runtime state (живёт только в БД)
    last_import_at TEXT,
    last_scan_at   TEXT,

    created_at     TEXT    NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    updated_at     TEXT    NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),

    UNIQUE (source_type, device_id)            -- одно устройство не дублируется
);
```

#### `recordings` — расширенные метаданные аудиозаписей

```sql
CREATE TABLE recordings
(
    source_id        TEXT PRIMARY KEY REFERENCES sources (id) ON DELETE CASCADE,
    import_source_id TEXT REFERENCES audio_import_sources (id) ON DELETE SET NULL,
    filename         TEXT NOT NULL,
    duration_ms      INTEGER, -- продолжительность в миллисекундах
    started_at       TEXT,
    finished_at      TEXT,
    audio_format     TEXT,    -- 'wav' | 'mp3' | 'aac' | 'm4a' | 'opus' и т.п.
    sample_rate      INTEGER,
    channels         INTEGER
);

CREATE INDEX idx_recordings_import_source ON recordings (import_source_id) WHERE import_source_id IS NOT NULL;
CREATE INDEX idx_recordings_time ON recordings (started_at, finished_at);
```

#### `transcripts` — варианты стенограмм

```sql
CREATE TABLE transcripts
(
    id                             TEXT PRIMARY KEY,
    source_id                      TEXT    NOT NULL REFERENCES sources (id) ON DELETE CASCADE, -- к какому Recording относится

    -- Модель и настройки
    model                          TEXT    NOT NULL,                                           -- 'whisper-large-v3' | 'gemini-2.5-flash' | 'deepgram-nova-3' и т.п.
    model_params                   TEXT,                                                       -- JSON с параметрами (language, prompt и т.п.)
    transcription_context_snapshot TEXT,                                                       -- хэш или snapshot использованного контекста

    -- Статус
    status                         TEXT    NOT NULL DEFAULT 'pending',                         -- 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled'
    error_message                  TEXT,

    -- Результат
    is_primary                     INTEGER NOT NULL DEFAULT 0,                                 -- 1 если это лучший транскрипт (выбран Judge или пользователем)
    is_draft                       INTEGER NOT NULL DEFAULT 0,                                 -- 1 если это черновая стенограмма (для предварительной сортировки)
    primary_selected_by            TEXT,                                                       -- 'judge' | 'user' | NULL — кто выбрал этот транскрипт как primary
    md_file_path                   TEXT,                                                       -- путь к .md-файлу с транскриптом внутри .source папки
    content_hash                   TEXT,                                                       -- SHA-256 для отслеживания изменений

    -- Timestamps
    created_at                     TEXT    NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    completed_at                   TEXT,
    processing_duration_ms         INTEGER                                                     -- сколько заняла транскрипция
);

CREATE INDEX idx_transcripts_source ON transcripts (source_id);
CREATE INDEX idx_transcripts_primary ON transcripts (source_id) WHERE is_primary = 1;
CREATE INDEX idx_transcripts_status ON transcripts (status) WHERE status != 'completed';
```

#### `jobs` — очередь фоновых задач

```sql
CREATE TABLE jobs
(
    id            TEXT PRIMARY KEY,
    document_id   TEXT REFERENCES documents (id) ON DELETE CASCADE,
    source_id     TEXT REFERENCES sources (id) ON DELETE CASCADE,
    job_type      TEXT    NOT NULL,
    -- Типы:
    -- 'transcribe'           — транскрипция аудио
    -- 'transcribe_draft'     — черновая транскрипция для сортировки
    -- 'judge_transcript'     — выбор лучшей стенограммы
    -- 'judge_categorize'     — определение папки для документа
    -- 'generate_summary'     — генерация Summary
    -- 'process_pdf'          — конвертация PDF в текст
    -- 'process_image'        — описание картинки через LLM
    -- 'fetch_dynamic'        — обновление динамического источника
    -- 'git_commit'           — коммит в git
    -- 'git_sync'             — синхронизация с remote
    -- 'calendar_sync'        — синхронизация календарей
    -- 'reindex'              — реиндексация из git
    -- 'trash_cleanup'        — очистка локальной корзины (файлы старше 30 дней)

    status        TEXT    NOT NULL DEFAULT 'queued', -- 'queued' | 'running' | 'completed' | 'failed' | 'cancelled'
    priority      INTEGER NOT NULL DEFAULT 5,        -- 1 (высший) — 10 (низший)
    payload       TEXT,                              -- JSON с параметрами задачи
    error_message TEXT,
    retry_count   INTEGER NOT NULL DEFAULT 0,
    max_retries   INTEGER NOT NULL DEFAULT 3,

    created_at    TEXT    NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    started_at    TEXT,
    completed_at  TEXT,
    next_retry_at TEXT
);

CREATE INDEX idx_jobs_status ON jobs (status, priority) WHERE status IN ('queued', 'running');
CREATE INDEX idx_jobs_document ON jobs (document_id) WHERE document_id IS NOT NULL;
```

#### `deletion_log` — история удалений (для папки "Trash")

При удалении документа (из git-папки или из Uncategorized) приложение **сначала** записывает snapshot в `deletion_log`,
**затем** удаляет файлы. Механизм восстановления зависит от `restore_strategy`:

- **`git`** — документ был в git. Восстановление через `git restore` по `git_commit_sha`.
- **`local_trash`** — документ не был в git (Uncategorized или git отключён). Физические файлы перемещаются в
  локальную корзину (`~/Library/Application Support/HiDocu/trash/<document_id>/`). Восстановление — перемещение файлов
  обратно. Через 30 дней файлы из локальной корзины автоматически удаляются (job `trash_cleanup`).

```sql
CREATE TABLE deletion_log
(
    id               TEXT PRIMARY KEY,
    document_id      TEXT NOT NULL, -- ID удалённого документа
    folder_id        TEXT,          -- из какой папки был удалён
    folder_path      TEXT,          -- путь папки на момент удаления
    title            TEXT NOT NULL,
    document_type    TEXT,
    body_preview     TEXT,          -- превью для отображения в Trash UI
    deleted_at       TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    expires_at       TEXT NOT NULL, -- дата автоочистки (deleted_at + 30 дней)

    -- Стратегия восстановления
    restore_strategy TEXT NOT NULL, -- 'git' | 'local_trash'
    git_commit_sha   TEXT,          -- коммит удаления (для restore_strategy = 'git')
    trash_path       TEXT           -- путь в локальной корзине (для restore_strategy = 'local_trash')
);

CREATE INDEX idx_deletion_log_expires ON deletion_log (expires_at);
CREATE INDEX idx_deletion_log_deleted ON deletion_log (deleted_at DESC);
```

#### `git_sync_state` — состояние синхронизации с git

```sql
CREATE TABLE git_sync_state
(
    repo_path     TEXT PRIMARY KEY,                -- путь к корню git-репозитория
    remote_url    TEXT,
    last_pull_at  TEXT,
    last_push_at  TEXT,
    last_pull_sha TEXT,                            -- SHA последнего pull
    last_push_sha TEXT,                            -- SHA последнего push
    has_conflicts INTEGER NOT NULL DEFAULT 0,
    sync_status   TEXT    NOT NULL DEFAULT 'idle', -- 'idle' | 'pulling' | 'pushing' | 'conflict' | 'error'
    error_message TEXT
);
```

#### `conflicts` — неразрешённые конфликты

```sql
CREATE TABLE conflicts
(
    id             TEXT PRIMARY KEY,
    repo_path      TEXT    NOT NULL REFERENCES git_sync_state (repo_path),
    file_path      TEXT    NOT NULL, -- путь к файлу с конфликтом относительно репозитория
    file_type      TEXT,             -- 'body' | 'summary' | 'metadata' | 'config'
    local_content  TEXT,
    remote_content TEXT,
    base_content   TEXT,             -- общий предок (для 3-way merge)
    resolved       INTEGER NOT NULL DEFAULT 0,
    resolution     TEXT,             -- 'local' | 'remote' | 'merged' | NULL
    detected_at    TEXT    NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    resolved_at    TEXT
);

CREATE INDEX idx_conflicts_unresolved ON conflicts (repo_path) WHERE resolved = 0;
```

#### `api_keys` — пользовательские API-ключи

```sql
CREATE TABLE api_keys
(
    id            TEXT PRIMARY KEY,
    provider      TEXT    NOT NULL UNIQUE, -- 'openai' | 'anthropic' | 'google' | 'deepgram' | 'assembly_ai' | ...
    display_name  TEXT    NOT NULL,
    -- Сами API-ключи хранятся в macOS Keychain.
    -- keychain_item содержит имя записи в Keychain для получения ключа.
    keychain_item TEXT    NOT NULL,
    base_url      TEXT,                    -- кастомный base URL (для self-hosted или прокси)
    is_active     INTEGER NOT NULL DEFAULT 1,
    created_at    TEXT    NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    last_used_at  TEXT
);
```

#### Полнотекстовый поиск (FTS5)

```sql
CREATE
VIRTUAL TABLE documents_fts USING fts5(
    title,
    body_text,
    summary_text,
    folder_path,
    content='documents',
    content_rowid='rowid',
    tokenize='unicode61 remove_diacritics 2'
);

-- Триггеры для автоматической синхронизации FTS с основной таблицей
CREATE TRIGGER documents_fts_insert
    AFTER INSERT
    ON documents
BEGIN
    INSERT INTO documents_fts(rowid, title, body_text, summary_text, folder_path)
    VALUES (new.rowid, new.title, '', new.summary_text, (SELECT fs_path FROM folders WHERE id = new.folder_id));
END;

CREATE TRIGGER documents_fts_delete
    AFTER DELETE
    ON documents
BEGIN
    INSERT INTO documents_fts(documents_fts, rowid, title, body_text, summary_text, folder_path)
    VALUES ('delete', old.rowid, old.title, '', old.summary_text, (SELECT path FROM folders WHERE id = old.folder_id));
END;

CREATE TRIGGER documents_fts_update
    AFTER UPDATE
    ON documents
BEGIN
    INSERT INTO documents_fts(documents_fts, rowid, title, body_text, summary_text, folder_path)
    VALUES ('delete', old.rowid, old.title, '', old.summary_text, (SELECT path FROM folders WHERE id = old.folder_id));
    INSERT INTO documents_fts(rowid, title, body_text, summary_text, folder_path)
    VALUES (new.rowid, new.title, '', new.summary_text, (SELECT path FROM folders WHERE id = new.folder_id));
END;
```

> **Примечание по `body_text`:** Полный текст Body не хранится в БД (он может быть очень большим). Для FTS-индексации
> Body текст читается из файла `body.md` и индексируется в FTS напрямую при создании/обновлении документа. В триггерах
> выше `body_text` заполняется пустой строкой — реальная индексация Body происходит отдельно, через прямую вставку в
> FTS-таблицу из кода приложения после чтения файла.

### Удаление документов

При удалении документа приложение выполняет следующие шаги:

1. **Создание записи в `deletion_log`** с snapshot метаданных (title, type, body_preview, folder_path).
2. **Определение стратегии восстановления:**
- Если документ закоммичен в git (`git_committed = 1`): `restore_strategy = 'git'`, в `git_commit_sha` сохраняется
  SHA текущего HEAD. Файлы удаляются из рабочей директории и коммитятся как удаление.
- Если документ не в git (Uncategorized, git отключён): `restore_strategy = 'local_trash'`. Файлы
  (.document папка целиком) перемещаются в `~/Library/Application Support/HiDocu/trash/<document_id>/`.
3. **Удаление записей из БД:** `documents`, `sources`, `recordings`, `transcripts`, `document_token_cache` —
   каскадно.
4. **Обновление FTS-индекса.**
5. **Установка `expires_at`** = `deleted_at + 30 дней`.

Восстановление из Trash:

- **`git`**: `git restore --source=<commit_sha> -- <path>`, затем реиндексация документа в БД.
- **`local_trash`**: перемещение файлов из trash-директории обратно в целевую папку, затем реиндексация в БД.

Очистка: периодический job `trash_cleanup` удаляет записи из `deletion_log` и файлы из локальной корзины, у которых
`expires_at < now()`.

---

### Реиндексация

При повреждении или удалении БД приложение может полностью восстановить её содержимое:

1. **Сканирование файловой системы.** Приложение обходит все известные директории (корневую директорию HiDocu и все
   подключённые git-репозитории), находит все папки и `.document`-папки.
2. **Парсинг `metadata.yaml`.** Для каждого документа читается `metadata.yaml`, из которого восстанавливаются
   метаданные.
3. **Парсинг Sources.** Для каждого документа сканируется папка `sources/`, читаются `metadata.yaml` каждого `.source`.
4. **Чтение Summary.** `summary.md` читается и кэшируется в БД.
5. **Индексация Body в FTS.** `body.md` читается и индексируется в FTS5.
6. **Восстановление approval status.** Документ считается `approved`, если файл присутствует в git-истории (имеет хотя
   бы один коммит). Если документ есть на диске, но не в git — он `unapproved`.
7. **Восстановление deletion_log.** Парсинг git-истории за последние 30 дней для поиска удалённых файлов.
8. **Синхронизация календарей.** Таблицы `calendars` и `calendar_events` восстанавливаются из конфигурации приложения +
   полная ресинхронизация с провайдерами календарей.
9. **Восстановление устройств.** Таблица `audio_import_sources` восстанавливается из конфигурации приложения (настройки
   устройств хранятся также в config-файле на диске).
10. **Подсчёт токенов.** Пересчитывается при первом обращении к папке (lazy).

Реиндексация запускается автоматически при обнаружении отсутствия или повреждения БД, а также доступна вручную через
меню приложения.

---

### Миграции

Схема БД версионируется через таблицу `schema_version`:

```sql
CREATE TABLE schema_version
(
    version     INTEGER PRIMARY KEY,
    applied_at  TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ', 'now')),
    description TEXT
);
```

Перед применением миграции создаётся автоматический бэкап БД. Поскольку БД является кэшем, в крайнем случае любая
миграция может быть заменена полной реиндексацией.

## Глобальные настройки приложения (Settings)

Глобальные настройки доступны через меню приложения (HiDocu → Settings) и применяются ко всему приложению. Настройки,
специфичные для отдельных папок (модели транскрипции, количество вариантов стенограмм, transcription/categorization
context и т.п.), описаны в разделе [Folder](#folder) и здесь не дублируются.

Глобальные настройки хранятся в файле `settings.yaml` внутри корневой директории данных приложения
(`~/Library/Application Support/HiDocu/settings.yaml`). Этот файл **не** версионируется в git, т.к. содержит
machine-specific пути и ссылки на Keychain. При необходимости пользователь может вручную скопировать этот файл на другую
машину и адаптировать пути.

---

### 1. General

| Настройка         | Тип  | Default    | Описание                                                                                                                                                                                                                                                                                       |
|-------------------|------|------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Language          | enum | System     | Язык интерфейса приложения. `system` = определяется из macOS.                                                                                                                                                                                                                                  |
| Data Directory    | path | `~/HiDocu` | Корневая директория, в которой хранятся все папки и документы HiDocu. Пользователь может изменить на любой путь, включая путь внутри облачного хранилища (iCloud Drive, Dropbox и т.п.), но приложение предупредит, что синхронизация через облако + git одновременно может вызвать конфликты. |
| Launch at Login   | bool | false      | Запускать приложение при входе в систему. Полезно для автоматического импорта записей с подключаемых устройств.                                                                                                                                                                                |
| Check for Updates | enum | `auto`     | `auto` — проверять и уведомлять, `manual` — только по запросу, `off` — не проверять.                                                                                                                                                                                                           |

### 2. API Keys

Централизованное управление API-ключами для всех внешних сервисов. Ключи хранятся в macOS Keychain, в БД хранится
только reference.

| Настройка  | Тип  | Default | Описание                                                                                                                         |
|------------|------|---------|----------------------------------------------------------------------------------------------------------------------------------|
| Провайдеры | list | (пусто) | Список подключённых провайдеров. Для каждого: provider name, API key (masked), base URL (опционально), статус (active/inactive). |

Поддерживаемые провайдеры (список расширяется):

- **Transcription**: Deepgram, AssemblyAI, OpenAI (Whisper API), Google (Chirp/Gemini)
- **LLM (для Judge, Summary, анализа)**: OpenAI, Anthropic, Google (Gemini)
- **Локальные модели**: не требуют API-ключа, настраиваются отдельно (см. Local Models)

Для каждого провайдера пользователь может указать **custom base URL**, что позволяет использовать self-hosted инстансы,
прокси или корпоративные эндпоинты.

### 3. Local Models

Настройки локальных моделей, которые работают без API-ключей и без отправки данных в интернет.

| Настройка             | Тип      | Default       | Описание                                                                                                                                                                                                    |
|-----------------------|----------|---------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Whisper Model         | enum     | `large-v3`    | Модель Whisper для локальной транскрипции. Варианты: `tiny`, `base`, `small`, `medium`, `large-v3`, `large-v3-turbo`. Приложение показывает требования к RAM и примерное время обработки для каждой модели. |
| Whisper Engine        | enum     | `whisper.cpp` | Движок для запуска Whisper: `whisper.cpp` (рекомендуется для Apple Silicon), `mlx-whisper`.                                                                                                                 |
| Local LLM             | optional | (не настроен) | Локальная LLM для Judge, Summary и категоризации. Поддержка через Ollama или MLX. Пользователь указывает: endpoint (`http://localhost:11434` для Ollama), название модели.                                  |
| Compute Device        | enum     | `auto`        | `auto` — приложение выбирает (GPU если доступен), `gpu` — только GPU (Metal/ANE), `cpu` — только CPU.                                                                                                       |
| Max Memory for Models | enum     | `auto`        | Максимальный объём RAM, который могут использовать локальные модели. `auto` — приложение определяет на основании доступной памяти. Варианты: `2GB`, `4GB`, `8GB`, `16GB`, `auto`.                           |

### 4. Default Models

Модели по умолчанию, которые используются, если на уровне папки не переопределены. Для каждой роли пользователь
выбирает модель из списка доступных (на основании подключённых API-ключей и локальных моделей).

| Настройка                    | Тип                | Default                          | Описание                                                                                                                                                                 |
|------------------------------|--------------------|----------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Draft Transcription Model    | model ref          | Local Whisper (`large-v3-turbo`) | Модель для черновой транскрипции (используется для предварительной сортировки документов по папкам). Должна быть быстрой и дешёвой.                                      |
| Primary Transcription Models | list of model refs | (пусто — требует настройки)      | Список моделей для генерации чистовых вариантов стенограмм. Порядок в списке = порядок генерации. Пример: `[Deepgram Nova-3, Gemini 2.5 Flash, Local Whisper large-v3]`. |
| LLM Judge Model              | model ref          | (пусто — требует настройки)      | Модель для LLM-Judge (выбор лучшей стенограммы, категоризация документов).                                                                                               |
| Summary Model                | model ref          | (пусто — требует настройки)      | Модель для генерации Summary.                                                                                                                                            |
| Transcription Variants       | number             | 3                                | Количество вариантов стенограммы по умолчанию (от 1). Количество не может превышать количество Primary Transcription Models.                                             |

> Если модели не настроены, приложение при первом запуске предлагает wizard для настройки: выбор между полностью
> локальным режимом (только Whisper + локальная LLM) и облачным (API-ключи). Приложение может работать только с
> локальными моделями, но качество транскрипции и Judge будет ниже.

### 5. Audio Import

Глобальные настройки импорта аудиозаписей. Настройки конкретных устройств и источников управляются в отдельном разделе
Settings → Devices & Import Sources (см. таблицу `audio_import_sources` в БД).

| Настройка                 | Тип         | Default                                 | Описание                                                                                                                                                                                                                                                                                  |
|---------------------------|-------------|-----------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Auto-detect New Devices   | bool        | true                                    | Показывать уведомление при подключении нового устройства с аудиозаписями и предлагать настроить импорт.                                                                                                                                                                                   |
| Import File Formats       | set of enum | `{wav, mp3, m4a, aac, opus, ogg, flac}` | Форматы файлов, которые распознаются как аудиозаписи при импорте.                                                                                                                                                                                                                         |
| Min Recording Duration    | duration    | 10 sec                                  | Минимальная длительность записи для импорта. Записи короче этого значения игнорируются (фильтрация случайных нажатий, системных звуков и т.п.).                                                                                                                                           |
| Auto-process After Import | bool        | true                                    | Автоматически запускать процесс обработки (черновая транскрипция → сортировка → чистовая транскрипция → Judge → Summary) после импорта новых записей. Если `false`, записи импортируются как Sources, но документы не создаются автоматически — пользователь запускает обработку вручную. |
| Notification on Import    | enum        | `banner`                                | `banner` — системное уведомление, `badge` — только бейдж на иконке, `none` — без уведомлений.                                                                                                                                                                                             |

#### Devices & Import Sources

Отдельный подраздел в Settings, который показывает список всех известных устройств и источников импорта
(таблица `audio_import_sources`). Для каждого источника:

| Настройка    | Тип    | Default           | Описание                                                                                                                         |
|--------------|--------|-------------------|----------------------------------------------------------------------------------------------------------------------------------|
| Display Name | string | (автоопределение) | Название для отображения в UI.                                                                                                   |
| Auto Import  | bool   | false             | Автоматически импортировать новые файлы при обнаружении. Для нового устройства всегда `false` до явного включения пользователем. |
| Active       | bool   | true              | Устройство активно. Если `false`, устройство игнорируется при сканировании.                                                      |
| Watch Path   | path   | (зависит от типа) | Путь для сканирования (для `folder_watch`, `icloud`, `dropbox`).                                                                 |

### 6. Calendars

Управление подключёнными календарями. Отдельный подраздел в Settings.

| Настройка                            | Тип      | Default      | Описание                                                                                                                                                                                                                                                                                       |
|--------------------------------------|----------|--------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Calendar Integrations                | list     | (пусто)      | Список подключённых календарных аккаунтов. Для каждого: провайдер (Apple Calendar, Google Calendar, CalDAV, Outlook), аккаунт, список календарей с toggle on/off для каждого.                                                                                                                  |
| Sync Interval                        | duration | 15 min       | Как часто синхронизировать события из включённых календарей. Варианты: `5 min`, `15 min`, `30 min`, `1 hour`, `manual only`.                                                                                                                                                                   |
| Sync Window                          | range    | -7d ... +30d | Диапазон дат для синхронизации событий. Пример: от 7 дней назад до 30 дней вперёд. События за пределами этого окна не загружаются. Прошлые события нужны для связывания с записями, которые были сделаны за последнюю неделю, но ещё не обработаны.                                            |
| Recording ↔ Event Matching Tolerance | duration | 15 min       | Допустимое расхождение по времени между началом/окончанием аудиозаписи и началом/окончанием календарного события при автоматическом связывании. Например, если встреча в календаре 10:00–11:00, а запись началась в 9:50 или закончилась в 11:10, она всё равно будет связана с этим событием. |

При подключении Apple Calendar приложение запрашивает разрешение через macOS EventKit framework. Для Google Calendar и
других — через OAuth2 flow.

### 7. Git

Глобальные настройки работы с git. Настройки конкретных репозиториев (remote URL и т.п.) управляются на уровне папок.

| Настройка               | Тип      | Default                                     | Описание                                                                                                                                                                   |
|-------------------------|----------|---------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Git Author Name         | string   | (из `git config`)                           | Имя автора для коммитов. По умолчанию берётся из глобального `git config`.                                                                                                 |
| Git Author Email        | string   | (из `git config`)                           | Email автора для коммитов.                                                                                                                                                 |
| Auto Sync               | bool     | true                                        | Автоматически синхронизироваться с remote-репозиториями (pull + push). Если `false`, синхронизация только вручную.                                                         |
| Sync Interval           | duration | 5 min                                       | Как часто выполнять auto sync. Варианты: `1 min`, `5 min`, `15 min`, `30 min`, `manual only`.                                                                              |
| Auto Commit on Approve  | bool     | true                                        | Автоматически коммитить документ при approve. Если `false`, approved-документы накапливаются и коммитятся вручную или по расписанию.                                       |
| Commit Message Template | string   | `"[HiDocu] {{action}}: {{document_title}}"` | Шаблон сообщения коммита. Доступные переменные: `{{action}}` (add/update/delete), `{{document_title}}`, `{{folder_path}}`, `{{date}}`.                                     |
| SSH Key Path            | path     | `~/.ssh/id_ed25519`                         | Путь к SSH-ключу для аутентификации с remote-репозиториями. Пользователь может указать другой ключ.                                                                        |
| Git Enabled             | bool     | false                                       | Глобальный выключатель git. Если `false`, приложение работает только с локальной файловой системой без версионирования. Папки можно подключить к git позже в любой момент. |

### 8. Context & Tokens

Настройки формирования контекста и подсчёта токенов.

| Настройка              | Тип    | Default      | Описание                                                                                                                                                                                                                                                                             |
|------------------------|--------|--------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Default Target LLM     | enum   | (не выбрана) | Модель, для которой по умолчанию показывается подсчёт токенов и лимиты. Варианты: `ChatGPT (GPT-4o)`, `ChatGPT (o3)`, `Claude Sonnet`, `Claude Opus`, `Gemini 2.5 Pro`, `Gemini 2.5 Flash`, `Custom...`. Влияет на выбор токенизатора и цветовую индикацию (зелёный/жёлтый/красный). |
| Custom Token Limit     | number | (из модели)  | Если выбрана модель, лимит подтягивается автоматически. Пользователь может переопределить вручную (например, если хочет оставить часть контекстного окна для ответа).                                                                                                                |
| Default Context Source | enum   | `summary`    | Что по умолчанию использовать при формировании контекста: `summary` или `body`. Переопределяется на уровне папки или документа.                                                                                                                                                      |
| Copy Context Format    | enum   | `markdown`   | Формат при копировании контекста в буфер обмена: `markdown` — как есть, `xml` — каждый документ обёрнут в XML-теги с метаданными (`<document title="..." date="...">...</document>`), `plain` — stripped markdown без форматирования.                                                |

### 9. Built-in Chat

Настройки встроенного чата с LLM.

| Настройка           | Тип       | Default       | Описание                                                                                                                                                                                                                |
|---------------------|-----------|---------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Chat Enabled        | bool      | true          | Показывать встроенный чат в интерфейсе. Если `false`, пользователь использует контекст только через копирование.                                                                                                        |
| Chat Model          | model ref | (не настроен) | Модель для встроенного чата. Выбирается из подключённых API-ключей.                                                                                                                                                     |
| System Prompt       | text      | null          | Системный промпт, который отправляется вместе с контекстом. Пользователь может редактировать.                                                                                                                           |
| Auto-attach Context | bool      | true          | Автоматически прикреплять контекст текущей открытой папки к каждому сообщению в чате. Если `false`, пользователь вручную выбирает, какой контекст прикрепить.                                                           |
| Chat History        | enum      | `per_folder`  | Где хранить историю чата: `per_folder` — отдельная история для каждой папки/контекста, `global` — одна общая история, `none` — не сохранять. История чата хранится в БД (не в git), т.к. не является частью документов. |

### 10. Privacy & Security

| Настройка               | Тип    | Default | Описание                                                                                                                                                                                                   |
|-------------------------|--------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Offline Mode            | bool   | false   | Полностью офлайн-режим. Блокирует все сетевые запросы: API-вызовы к облачным моделям, синхронизацию git с remote, синхронизацию календарей. Работают только локальные модели и локальная файловая система. |
| Allow Unsandboxed Shell | bool   | false   | Разрешить выполнение shell-команд динамических источников вне sandboxed-окружения (с доступом к файловой системе, БД и т.п.). Требует явного подтверждения при включении с предупреждением о рисках.       |
| Clear Database          | action | —       | Удалить и пересоздать БД (запускает полную реиндексацию). Данные не теряются, т.к. БД — кэш.                                                                                                               |
| Export All Data         | action | —       | Экспортировать все данные приложения (настройки, БД, список устройств) в архив для бэкапа или переноса на другую машину. Документы и git-репозитории не включаются (они уже хранятся на диске / в remote). |

### 11. Notifications

| Настройка                | Тип  | Default  | Описание                                                                                                 |
|--------------------------|------|----------|----------------------------------------------------------------------------------------------------------|
| Import Complete          | enum | `banner` | Уведомление о завершении импорта записей. `banner` / `badge` / `none`.                                   |
| Transcription Complete   | enum | `banner` | Уведомление о завершении транскрипции.                                                                   |
| Sync Conflicts           | enum | `banner` | Уведомление о конфликтах при git-синхронизации. Рекомендуется `banner`, т.к. конфликты требуют внимания. |
| Categorization Uncertain | enum | `banner` | Уведомление, когда LLM-Judge не смог уверенно определить папку и документ попал в Uncategorized.         |

---

### Хранение настроек

```yaml
# ~/Library/Application Support/HiDocu/settings.yaml
general:
  language: system
  data_directory: ~/HiDocu
  launch_at_login: false
  check_for_updates: auto

local_models:
  whisper_model: large-v3
  whisper_engine: whisper.cpp
  local_llm:
    endpoint: http://localhost:11434
    model: llama3.1:8b
  compute_device: auto
  max_memory: auto

default_models:
  draft_transcription: local_whisper:large-v3-turbo
  primary_transcription:
    - deepgram:nova-3
    - google:gemini-2.5-flash
    - local_whisper:large-v3
  transcription_variants: 3
  judge: google:gemini-2.5-pro
  summary: anthropic:claude-sonnet

audio_import:
  auto_detect_new_devices: true
  import_file_formats: [ wav, mp3, m4a, aac, opus, ogg, flac ]
  min_recording_duration: 10s
  # Список известных устройств
  devices:
    - id: "uuid-generated-1"
      source_type: hidock
      device_id: "H1-SN-12345678"
      display_name: "My HiDock H1"
      auto_import: true
      is_active: true
    - id: "uuid-generated-2"
      source_type: folder_watch
      watch_path: "~/Dropbox/Recordings"
      display_name: "Dropbox Folder"
      auto_import: false

calendars:
  sync_interval_sec: 900
  # Список подключенных аккаунтов
  accounts:
    - id: "uuid-cal-1"
      provider: google
      account_name: "john.doe@gmail.com"
      # Токены авторизации хранятся в Keychain, здесь только ссылка на аккаунт
      calendars:
        - calendar_id: "primary"
          name: "John Doe"
          color: "#4285F4"
          is_enabled: true
        - calendar_id: "addressbook#contacts@group.v.calendar.google.com"
          name: "Birthdays"
          is_enabled: false

git:
  author_name: John Doe
  author_email: john@example.com
  auto_sync: true
  sync_interval_sec: 300
  auto_commit_on_approve: true
  commit_message_template: "[HiDocu] {{action}}: {{document_title}}"
  ssh_key_path: ~/.ssh/id_ed25519
  enabled: true

context:
  default_target_llm: chatgpt-gpt4o
  custom_token_limit: null
  default_context_source: summary
  copy_context_format: markdown

chat:
  enabled: true
  model: anthropic:claude-sonnet
  system_prompt: null  # null = не использовать
  auto_attach_context: true
  history: per_folder

privacy:
  offline_mode: false
  allow_unsandboxed_shell: false

notifications:
  import_complete: banner
  transcription_complete: banner
  sync_conflicts: banner
  categorization_uncertain: banner
```

> **Примечание:** API-ключи и OAuth-токены календарей не хранятся в settings.yaml, они находятся в macOS
> Keychain. Однако список подключенных устройств и календарей (их ID, названия и настройки) хранится именно здесь, что
> позволяет восстановить конфигурацию после удаления базы данных. БД используется только для кэширования событий и
> статусов синхронизации.

## Интерфейс

UI/UX приложения соответствует современным стандартам macOS и Apple Human Interface Guidelines. Основные элементы интерфейса:
- **Sidebar:** Список папок и документов. Фильтры, сортировка, поиск.
- **Трех колоночный Layout для работы с папками и документами:**
  - **Sidebar:** Список папок и документов, подключенные устройства
  - **Document List View:** Список документов внутри выбранной папки с краткой информацией (название, дата, статус транскрипции, связанное событие календаря и т.п.)
  - **Main View:** Содержимое выбранного документа, включая метаданные, стенограммы, summary, связанные события календаря, sources (аудиофайлы) и т.п.
- **Двухколонный Layout для работы с устройствами:**
  - **Main View:** подробная информация о выбранном устройстве, список записей, настройки импорта и т.п.

